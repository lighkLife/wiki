# 组合模式

## 背景
树形结构在软件中随处可见，例如操作系统中的目录结构、应用软件中的菜单、办公系统中的公司组织结构等。如何运用面向对象的方式来处理这种树形结构是组合模式需要解决的问题。组合模式通过一种巧妙的设计方案使得用户可以一致性地处理整个树形结构或者树形结构的一部分，也可以一致性地处理树形结构中的叶子节点（不包含子节点的节点）和容器节点（包含子节点的节点）。

开发一个杀毒（AntiVirus）软件，该软件既可以对某个文件夹（Folder）杀毒，也可以对某个指定的文件（File）进行杀毒。该杀毒软件还可以根据各类文件的特点，为不同类型的文件提供不同的杀毒方式，例如图像文件（ImageFile）和文本文件（TextFile）的杀毒方式就有所差异。

## 定义
组合模式（Composite Pattern）：组合多个对象形成树形结构以表示具有“部分—整体”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，又可以称为“部分—整体”（Part-Whole）模式。

```uml
interface Component {
    + operation()
    --
    + add(Component)
    + remove(Component)
    + getChildren(): Component[]
}

class Leaf implements Component{
    + operation()
}
class Composite implements Component {
    - children: Component[]
    + operation()
    + add(Component)
    + remove(Component)
    + getChildren(): Component[]
}
note left of Composite::"operation()"
    for(Component: child: children) {
        child.operation();
    }
end note
Component <--o Composite::children

class Client #palegreen
Client ..[#red]> Component
```

## 实现

```uml
abstract AbstractFile {
    + add(AbstractFile)
    + remove(AbstractFile)
    + getChildren(): AbstractFile[]
    + killVirus() 
}
class TextFile implements AbstractFile {
    + killVirus()
}
class ImageFile implements AbstractFile {
    + killVirus()
}
class Folder implements AbstractFile {
    - children: AbstractFile[]
    + killVirus() 
    + add(AbstractFile)
    + remove(AbstractFile)
    + getChildren(): AbstractFile[]

}
AbstractFile <--o Folder::children
note left of Folder::"killVirus()"
    for(AbstractFile: child: children) {
        child.killVirus();
    }
end note

class Client #palegreen
Client ..[#red]> AbstractFile
```

## 评价
### 优点
1. 合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次。它让客户端忽略了层次的差异，方便对整个层次结构进行控制。
2. 在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合开闭原则。

### 缺点
在增加新构件时很难对容器中的构件类型进行限制。有时希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件。使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自相同的抽象层。在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂