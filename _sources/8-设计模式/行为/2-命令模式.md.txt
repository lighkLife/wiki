# 命令模式

## 背景
开发一个桌面版应用程序，该应用程序为用户提供了一系列自定义功能键，用户可以通过这些功能键来实现一些快捷操作。
在设置功能键的时候每个人都有自己的喜好，例如有的人喜欢将第一个功能键设置为“打开帮助文档”，有的人则喜欢将该功能键设置为“最小化至托盘”。为了让用户能够灵活地进行功能键的设置，开发人员提供了一个“功能键设置”窗口，如图：

![快捷键](../img/quikkey.png)

如何设计才能满足灵活绑定功能键与具体功能之间的关系？
- 很容易想到将不同的功能命令封住为不同的类，如 ShowHelpCmd、MinimizeCmd、ScreenshotCmd，基于面向抽象编程的理念，为这些命令抽象一个接口 Cmd 
- 要实现功能键与具体功能灵活组合，很容易想到使用聚合关系，不同的功能对象和不同的 Cmd 实现进行组合，就可以相对优雅的解决上述需求 

上面的这种思路就是命令模式。在软件开发中，经常需要向某些对象发送请求（调用其中的某个或某些方法），但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个。此时，特别希望能够以一种松耦合的方式来设计软件，使得请求发送者与请求接收者能够消除彼此之间的耦合，让对象之间的调用关系更加灵活，可以灵活地指定请求接收者以及被请求的操作。命令模式为此类问题提供了一个较为完美的解决方案。

## 定义
命令模式（Command Pattern）：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作（Action）模式或事务（Transaction）模式。

命令模式可以将请求发送者和接收者完全解耦。发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。

```uml
interface Command {
    + execute()
}
class ConcreteCommandA implements Command {
    + execute()
}
class ConcreteCommandB implements Command {
    + execute()
}
class Invoker {
    - command: Command
    + setCommand(cmd: Command)
}
Invoker::command o-->  Command


```

1. Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute（）等方法，通过这些方法可以调用请求接收者的相关操作。
2. ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法。它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute（）方法时，将调用接收者对象的相关操作（Action）。
3. Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute（）方法，从而实现间接调用请求接收者的相关操作。
4. Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。