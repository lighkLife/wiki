# 原型模式

## 背景
如果你有一个对象， 并希望生成与其完全相同的一个复制品，该如何实现呢？ 
首先，你必须新建一个属于相同类的对象。然后，你必须遍历原始对象的所有成员变量，
并将成员变量值复制到新对象中。

但是, 这样可能面临如下问题：
- 并非所有对象都能通过这种方式进行复制，因为有些对象可能拥有私有成员变量，
  它们在对象本身以外是不可见的。
- 必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。而且，有时你只知道
  对象所实现的接口，而不知道其所属的具体类。


## 定义
原型模式（Prototype Pattern）：使用原型实例指定创建对象的种类，并且通过克隆这些原型创建新的对象。

```{uml}
interface Prototype {
    + clone(): Prototype
}

class ConcretePrototypeA implements Prototype {
    + clone(): Prototype
}
class ConcretePrototypeB implements Prototype {
    + clone(): Prototype
}

class Client #palegreen {
    + operation()
}
note left of Client::"operation()"
    p = prototype.clone()
end note

Client --[#red]> Prototype
```

## 实现

### 浅克隆
在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，
则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。

### 深克隆
在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的
所有引用对象也复制一份给克隆对象。在Java语言中，如果需要实现深克隆，可以通过序列化（Serialization）
等方式来实现。
