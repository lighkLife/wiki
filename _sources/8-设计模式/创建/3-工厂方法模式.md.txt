# 工厂方法模式

## 背景
使用简单工厂模式，客户端无需负责具体产品的创建，通过工厂方法进行创建，客户端只是使用产品。
但是，如果需要新增产品类型，就需要修改工厂类，如何实现增加新产品而不影响已有代码？

开发一个系统运行日志记录器（Logger），该记录器可以通过多种途径保存系统的运行日志，例如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式，也支持新增记录方式，如 socket 记录方式。

## 定义
工厂方法模式（Factory Method Pattern）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。
工厂方法模式让一个类的实例化延迟到其子类。

```{uml}
interface Product
class ConcreteProductA implements Product
class ConcreteProductB implements Product

interface Factory{
    + createProduct(): Product
}
class ConcreteFactoryA implements Factory{
    + createProduct(): Product
}
class ConcreteFactoryB implements Factory{
    + createProduct(): Product
}

ConcreteProductA <.. ConcreteFactoryA:create
ConcreteProductB <.. ConcreteFactoryB:create

class Client #palegreen
Factory <..[#red] Client:use
Client ..[#red]>  Product:use
```

## 实现
```{uml}
interface Logger
class DatabaseLogger implements Logger
class FileLogger implements Logger
class SocketLogger implements Logger

interface Factory{
    + createProduct(): Logger
}
class DatabaseLoggerFactory{
    + createProduct(): Logger
}
class FileLoggerFactory{
    + createProduct(): Logger
}
class SocketLoggerFactory{
    + createProduct(): Logger
}

DatabaseLoggerFactory ..|> Factory
FileLoggerFactory ..|> Factory
SocketLoggerFactory ..|> Factory

DatabaseLogger <.. DatabaseLoggerFactory:create
FileLogger <.. FileLoggerFactory:create
SocketLogger <.. SocketLoggerFactory:create

class Client #palegreen
Logger <..[#red] Client:use
Client ..[#red]>  Factory:use
```

## 评价
优点
- 符合单一职责原则，每个产品工厂只创建自己的对应的产品
- 符合开闭原则，增加新的产品，无需修改现有工厂类和客户端（客户端可以通过反射或读取配置文件决定使用哪个产品工厂）

缺点
- 应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 