# 拓扑排序

## 知识讲解

**拓扑排序**（Topological Sorting）：一种对 **有向无环图（DAG）** 的所有顶点进行线性排序的方法，使得图中任意一点 `u` 和  `v`, 如果存在有向边 `<u,v>`, 则 `u` 必须在  `v` 之前出现,对有向图进行拓扑排序产生的**线性序列**称为满足拓扑次序的序列，简称拓扑排序。

图的拓扑排序是针对有向无环图（DAG）来说的，无向图和有向有环图没有拓扑排序，或者说不存在拓扑排序。


![alt text](img/image-4.png)

一个图可能存在多个拓扑序列，比如上图的拓扑序列可以是:

$$V_1 \rightarrow V_2 \rightarrow V_3 \rightarrow V_4 \rightarrow V_5 \rightarrow V_6$$

也可以是：

$$V_1 \rightarrow V_2 \rightarrow V_3 \rightarrow V_4 \rightarrow V_6 \rightarrow V_5$$

## BFS 实现(Kahn 算法)

```{important}
Kahn 算法主要基于节点的**入读**进行图遍历，每得到一个**入读=0**的节点，就得到下一个节点，具体操作如下：

**1. 不断找寻有向图中入度为 0 的顶点，将其输出。**<br>
**2. 然后删除入度为 0 的顶点和从该顶点出发的有向边。**<br>
**3. 重复上述操作直到图为空，或者找不到入度为 0 的节点为止。**<br>
```

可以看到上述操作其是就是对图进行 BFS 遍历，其关键在于引入**队列**来暂存**入度=0**的节点，如果**有环**，就会发现环里面的节点入度都大于0，也就导致不能完美遍历整个图，也就是排序结果数小于总节点数。

{lineno-start=1 emphasize-lines="23,29,33,36"}
```Java
// 使用 inDegree[i] 维护节点的入读
// 使用 queue 维护入读为 0 的节点，然后再以 queue 中的节点作为出发点，继续遍历下一层节点
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 排序结果指针
        int resultIndex = 0;
        // 排序结果容器
        int[] result = new int[numCourses];
        // 维护每个节点的入度 inDegree[i]
        int[] inDegree = new int[numCourses];
        List<List<Integer>> edges = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            edges.add(new ArrayList<>());
        }
        for (int[] it : prerequisites) {
            edges.get(it[1]).add(it[0]);
            inDegree[it[0]]++;
        }
        Queue<Integer> queue = new ArrayDeque<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                // 入度为 0 的节点加入队列和最终结果
                queue.add(i);
                result[resultIndex++] = i;
            }
        }
        while (!queue.isEmpty()) {
            // queue 维护入读为 0 的节点， 删除入度为 0 的 vertex
            Integer vertex = queue.poll();
            // 访问 vertex 的下一层
            for (Integer next : edges.get(vertex)) {
                // 删除 vertex 后，相连的节点入读就需要减 1
                inDegree[next]--;
                if (inDegree[next] == 0) {
                    // 入度为 0 的节点加入队列和最终结果
                    queue.add(next);
                    result[resultIndex++] = next;
                }
            }
        }
        // 这里很重要，只有排序结果数和节点数想等，才说明没有环，当前图存在一个拓扑排序
        return resultIndex == numCourses ? result : new int[0];
    }
}
```

## DFS 实现

```{important}
基于 DFS 实现拓扑排序算法的基本思想：

1. 对于一个顶点 u，深度优先遍历从该顶点出发的有向边 `<u,v>`:
    - 如果从该顶点 u 出发的所有相邻顶点 v 都已经搜索完毕，则回溯到顶点 u 时，该顶点 u 应该位于其所有相邻顶点 v 的前面（拓扑序列中）。
2. 这样一来，当我们对每个顶点进行深度优先搜索，在回溯到该顶点时将其放入栈中，则最终从栈顶到栈底的序列就是一种拓扑排序。
```

DFS 遍历的一个重点是一边遍历，一边使用 visited[] 标记节点状态(0-未访问 1-遍历中 2-遍历完毕)，如果 **有环**，那么深度优先遍历从该顶点出发的有向边时，就会发现有节点已经被标记为 **遍历中**

{lineno-start=1 emphasize-lines="29,32,34,43"}
```Java
class Solution {
    int resultIndex; // 配合 result 数组模拟栈
    int[] result; // 栈，保存拓扑排序结果
    int[] visited; // 用来标记访问状态（访问当前节点所有相邻节点） 0-未访问 1-访问中 2-访问完
    boolean valid = true; // 标记是否有环

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        resultIndex = numCourses - 1;
        result = new int[numCourses];
        visited = new int[numCourses];
        List<List<Integer>> edges = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            edges.add(new ArrayList<>());
        }
        for (int i = 0; i < prerequisites.length; i++) {
            int[] it = prerequisites[i];
            edges.get(it[1]).add(it[0]);
        }
        for (int i = 0; i < numCourses && valid; i++) {
            if (visited[i] == 0) {
                dfs2(edges, i);
            }
        }
        return valid ? result : new int[0];
    }

    public void dfs2(List<List<Integer>> edges, int vertex) {
        // 将当前节点标记为 访问中
        visited[vertex] = 1;
        // 深度优先遍历从该顶点出发的有向边
        for (Integer next : edges.get(vertex)) {
            if (visited[next] == 0) {
                dfs2(edges, next);
            } else if (visited[next] == 1) {
                // cycle
                valid = false;
                return;
            }
        }
        // 从该顶点 vertex 出发的所有相邻顶点都已经搜索完毕
        result[resultIndex--] = vertex;
        // 将当前节点标记为 访问完
        visited[vertex] = 2;
    }
}
```

## 参考

1. [拓扑排序简介. 算法通关手册（LeetCode）](https://algo.itcharge.cn/08.Graph/02.Graph-Traversal/05.Graph-Topological-Sorting)