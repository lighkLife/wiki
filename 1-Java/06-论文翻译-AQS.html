<!doctype html>
<html class="no-js" lang="zh-CN" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="索引" href="../genindex.html" /><link rel="search" title="搜索" href="../search.html" /><link rel="next" title="Rust 相关" href="../2-Rust/index.html" /><link rel="prev" title="HashMap实现" href="05-HashMap%E5%AE%9E%E7%8E%B0.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2023.09.10 -->
        <title>论文翻译-AQS - 文档</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinxcontrib-images/LightBox2/lightbox2/dist/css/lightbox.css?v=5c84f910" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="../_static/my_style.css?v=ec38ee01" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">  文档</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">  文档</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="搜索" name="q" aria-label="搜索">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="0-index.html">Java 相关</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Java 相关</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="A-fatal-error%60SIGSEGV%20%280xb%29%60.html">A fatal error <code class="docutils literal notranslate"><span class="pre">SIGSEGV</span> <span class="pre">(0xb)</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="00-Q%26A.html">Q&amp;A</a></li>
<li class="toctree-l2"><a class="reference internal" href="01-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html">JDK 动态代理</a></li>
<li class="toctree-l2"><a class="reference internal" href="02-Java%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95.html">Java 桥接方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="03-Java%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8.html">Java四种引用</a></li>
<li class="toctree-l2"><a class="reference internal" href="04-String%E5%AE%9E%E7%8E%B0.html">String 实现</a></li>
<li class="toctree-l2"><a class="reference internal" href="05-HashMap%E5%AE%9E%E7%8E%B0.html">HashMap实现</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">论文翻译-AQS</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../2-Rust/index.html">Rust 相关</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Rust 相关</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../2-Rust/test.html">测试文件</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../3-%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80/index.html">其他语言</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of 其他语言</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../3-%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80/test.html">测试文件</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../4-Middleware/0-index.html">中间件</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of 中间件</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../4-Middleware/MinIO/MinIO%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8D%95%E8%8A%82%E7%82%B9%E9%83%A8%E7%BD%B2.html">MinIO介绍与单节点部署</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4-Middleware/MinIO/MinIO%E5%A4%9A%E8%8A%82%E7%82%B9%E9%83%A8%E7%BD%B2.html">MinIO多节点部署</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4-Middleware/1-How-tomcat-works.html">How-tomcat-works</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../5-IoT/index.html">物联网</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of 物联网</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../5-IoT/test.html">测试文件</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../6-OS/0-index.html">操作系统</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of 操作系统</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../6-OS/00-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html">linux常用命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6-OS/01-Ubuntu%20%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html">Ubuntu 使用问题记录</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../7-Spring/0-index.html">Spring 框架</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of Spring 框架</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../7-Spring/00-Spring%20IoC%20%E5%AE%B9%E5%99%A8.html">Spring IoC 容器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7-Spring/01-Spring%20%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE.html">Spring 容器配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7-Spring/02-Resource.html">Resource</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7-Spring/03-%E9%AA%8C%E8%AF%81%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html">验证、数据绑定和类型转换</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7-Spring/04-SpEL.html">SpEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7-Spring/05-AOP%E7%BC%96%E7%A8%8B.html">AOP编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7-Spring/06-SpringMVC-DispatcherServlet.html">SpringMVC-DispatcherServlet</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7-Spring/07-SpringMVC%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA.html">SpringMVC请求拦截</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0-index.html">设计模式</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle navigation of 设计模式</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.html">设计模式的六大原则</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../9-%E5%AF%BB%E8%8A%B3%E6%8B%BE%E9%A6%99/0-index.html">寻芳拾香</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle navigation of 寻芳拾香</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../9-%E5%AF%BB%E8%8A%B3%E6%8B%BE%E9%A6%99/00-%E4%BD%BF%E7%94%A8Sphinx%E6%90%AD%E5%BB%BA%E7%9F%A5%E8%AF%86%E5%BA%93.html">使用 Sphinx 搭建知识库</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9-%E5%AF%BB%E8%8A%B3%E6%8B%BE%E9%A6%99/02-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%A4%84%E7%90%86.html">字符串中的变量处理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9-%E5%AF%BB%E8%8A%B3%E6%8B%BE%E9%A6%99/03-Git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.html">Git 使用记录</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9-%E5%AF%BB%E8%8A%B3%E6%8B%BE%E9%A6%99/04-MapReduce.html">MapReduce</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9-%E5%AF%BB%E8%8A%B3%E6%8B%BE%E9%A6%99/05-%E6%95%B0%E7%89%A9%E8%9E%8D%E5%90%88-%E7%AC%94%E8%AE%B0.html">数物融合-笔记</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="aqs">
<h1>论文翻译-AQS<a class="headerlink" href="#aqs" title="Link to this heading">#</a></h1>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>原文： http://gee.cs.oswego.edu/dl/papers/aqs.pdf</p>
</div>
<section id="abstract">
<h2>ABSTRACT 摘要<a class="headerlink" href="#abstract" title="Link to this heading">#</a></h2>
<p>Most synchronizers (locks, barriers, etc.) in the J2SE1.5
java.util.concurrent package are constructed using a small
framework based on class <code class="docutils literal notranslate"><span class="pre">AbstractQueuedSynchro-nizer</span></code>.
This framework provides common mechanics for
atomically managing synchronization state, blocking and
unblocking threads, and queuing. The paper describes the
rationale, design, implementation, usage, and performance of this
framework.</p>
<p>在 J2SE1.5 的 java.util.concurrent 包中，大多数同步器（locks、barriers 等）
都是使用一个基于<code class="docutils literal notranslate"><span class="pre">AbstractQueuedSynchro-nizer</span></code> 类的小型框架构建的。
这个框架为同步状态的原子化管理、线程的阻塞和解除、队列操作提供了通用机制。
这篇论文阐述了这个框架的原理、设计、实现、使用和性能。</p>
</section>
<section id="categories-and-subject-descriptors">
<h2>Categories and Subject Descriptors<a class="headerlink" href="#categories-and-subject-descriptors" title="Link to this heading">#</a></h2>
<p>D.1.3 [Programming Techniques]: Concurrent Programming – Parallel Programming</p>
</section>
<section id="general-terms">
<h2>General Terms<a class="headerlink" href="#general-terms" title="Link to this heading">#</a></h2>
<p>Algorithms, Measurement, Performance, Design.</p>
</section>
<section id="keywords">
<h2>Keywords<a class="headerlink" href="#keywords" title="Link to this heading">#</a></h2>
<p>Synchronization, Java</p>
</section>
<section id="introduction">
<h2>1. INTRODUCTION 介绍<a class="headerlink" href="#introduction" title="Link to this heading">#</a></h2>
<p>Java tm release J2SE-1.5 introduces package java.util.concurrent, a
collection of medium-level concurrency support classes created
via Java Community Process (JCP) Java Specification Request
(JSR) 166. Among these components are a set of synchronizers –
abstract data type (ADT) classes that maintain an internal
synchronization state (for example, representing whether a lock
is locked or unlocked), operations to update and inspect that
state, and at least one method that will cause a calling thread to
block if the state requires it, resuming when some other thread
changes the synchronization state to permit it. Examples include
various forms of mutual exclusion locks, read-write locks,
semaphores, barriers, futures, event indicators, and handoff
queues.</p>
<p>Java 1.5 版本引入 java.util.concurrent 包，这里面包含了一些中级的并发支持类，在 JCP
JSR 166 中创建。）。在这些组件中是一组同步器——抽象数据结构类（ADT），维护内部的同步状态
（例如，代表一把锁是锁定状态还是解锁状态），更新和检查状态的操作，以及当状态需要同步器时，
特定的方法会导致调用线程阻塞，直到另一个线程更改同步状态，以允许其继续运行。示例来自各形式的
互斥锁，读写锁、信号量、屏障、futures、事件指示器、操作队列。</p>
<p>As is well-known (see e.g., <a class="footnote-reference brackets" href="#id23" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>) nearly any synchronizer can be
used to implement nearly any other. For example, it is possible to
build semaphores from reentrant locks, and vice versa. However,
doing so often entails enough complexity, overhead, and
inflexibility to be at best a second-rate engineering option.
Further, it is conceptually unattractive. If none of these constructs
are intrinsically more primitive than the others, developers
should not be compelled to arbitrarily choose one of them as a
basis for building others. Instead, JSR166 establishes a small
framework centered on class AbstractQueuedSynchro-
nizer, that provides common mechanics that are used by most
of the provided synchronizers in the package, as well as other
classes that users may define themselves.</p>
<p>众所周知(见例子, <a class="footnote-reference brackets" href="#id23" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>) ，大多数同步器之间可以互相实现。例如，可以使用重入锁实现信号量，反之亦然。然而，
这样做做往往相当复杂，开销过大，不灵活，只能作为次等的工程选择。此外，这在概念上也不吸引人。
如果每一本质上更基本的同步器，那么开发人员就不应该被强迫任意选择一种同步器作为构建其他同步器的基础。
所以，JSR166 建立了一个以 <code class="docutils literal notranslate"><span class="pre">AbstractQueuedSynchro-nizer</span></code> 类为中心的小型框架，改类为并发包中的
大多数同步器提供了一个通用的机制，也可被用户自定义类使用。</p>
<p>The remainder of this paper discusses the requirements for this
framework, the main ideas behind its design and implementation,
sample usages, and some measurements showing its performance
characteristics.</p>
<p>本文的其余部分讨论了这个框架的要求、其设计和实现背后的主要思想、使用示例，以及展示一些性能指标的测量结果。</p>
</section>
<section id="requirements">
<h2>2.REQUIREMENTS 要求<a class="headerlink" href="#requirements" title="Link to this heading">#</a></h2>
<section id="functionality">
<h3>2.1 Functionality 功能<a class="headerlink" href="#functionality" title="Link to this heading">#</a></h3>
<p>Synchronizers possess two kinds of methods <a class="footnote-reference brackets" href="#id24" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>: at least one
acquire operation that blocks the calling thread unless/until the
synchronization state allows it to proceed, and at least one
release operation that changes synchronization state in a way that
may allow one or more blocked threads to unblock.</p>
<p>同步器要具备两种方法 <a class="footnote-reference brackets" href="#id24" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>：至少一种获取操作，用来阻塞调用线程，除非/直到
同步状态允许线程继续处理；以及至少一种释放操作，用来改变同步状态，从而允许一个或
多个阻塞的线程解除阻塞。</p>
<p>The <code class="docutils literal notranslate"><span class="pre">java.util.concurrent</span></code> package does not define a single unified
API for synchronizers. Some are defined via common interfaces
(e.g., Lock), but others contain only specialized versions. So,
acquire and release operations take a range of names and forms
across different classes. For example, methods <code class="docutils literal notranslate"><span class="pre">Lock.lock</span></code>,
<code class="docutils literal notranslate"><span class="pre">Semaphore.acquire</span></code>, <code class="docutils literal notranslate"><span class="pre">CountDownLatch.await</span></code>, and
<code class="docutils literal notranslate"><span class="pre">FutureTask.get</span></code> all map to acquire operations in the
framework. However, the package does maintain consistent
conventions across classes to support a range of common usage
options. When meaningful, each synchronizer supports:</p>
<ul class="simple">
<li><p>Nonblocking synchronization attempts (for example,
`tryLock``) as well as blocking versions.</p></li>
<li><p>Optional timeouts, so applications can give up waiting.</p></li>
<li><p>Cancellability via interruption, usually separated into one
version of acquire that is cancellable, and one that isn’t.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">java.util.concurrent</span></code> 并没有为同步器定义一个统一的API。一些是通过通用接口
定义的（例如 Lock ），但其他只包含特定的版本。因此，获取和释放操作，在不同的类中
采用了不同的名称和形式。例如这些方法 <code class="docutils literal notranslate"><span class="pre">Lock.lock</span></code>，<code class="docutils literal notranslate"><span class="pre">Semaphore.acquire</span></code>，
<code class="docutils literal notranslate"><span class="pre">CountDownLatch.await</span></code> 和 <code class="docutils literal notranslate"><span class="pre">FutureTask.get</span></code> 都映射为框架中的获取操作。
然而，这个包在类之间保持了一致的约定，来支持一系列的使用选项。如果有意义，每个同步器都支持：</p>
<ul class="simple">
<li><p>非阻塞的同步尝试（例如 <code class="docutils literal notranslate"><span class="pre">tryLock</span></code>）, 以及阻塞的版本</p></li>
<li><p>可选的超时机制，以便应用程序可以放弃等待。</p></li>
<li><p>通过中断实现取消功能，获取操作通常分为一个可取消的版本，以及一个不能取消的版本。</p></li>
</ul>
<p>Synchronizers may vary according to whether they manage only
exclusive states – those in which only one thread at a time may
continue past a possible blocking point – versus possible shared
states in which multiple threads can at least sometimes proceed.
Regular lock classes of course maintain only exclusive state, but
counting semaphores, for example, may be acquired by as many
threads as the count permits. To be widely useful, the framework
must support both modes of operation.</p>
<p>同步器可能根据他们管理的状态是独占状态还是共享状态而有所不同。独占状态是指
一次只有一个线程可以继续通过可能的阻塞点，而共享状态则允许多个线程至少有时可以继续处理。
当然，常规的锁类只维护独占状态，但是，例如信号量，只要许可证数量足够，就可以被读多个线程获取。
为了广泛应用，框架必须支持这两种操作模式。</p>
<p>The java.util.concurrent package also defines interface
<code class="docutils literal notranslate"><span class="pre">Condition</span></code>, supporting monitor-style await/signal operations
that may be associated with exclusive <code class="docutils literal notranslate"><span class="pre">Lock</span></code> classes, and whose
implementations are intrinsically intertwined with their
associated <code class="docutils literal notranslate"><span class="pre">Lock</span></code> classes.</p>
<p><code class="docutils literal notranslate"><span class="pre">java.util.concurrent</span></code> 包还定义了<code class="docutils literal notranslate"><span class="pre">Condition</span></code>接口，支持与独占锁<code class="docutils literal notranslate"><span class="pre">Lock</span></code>类关联的监视器
风格的 <code class="docutils literal notranslate"><span class="pre">await/signal</span></code> 操作，这些实现与它们关联的<code class="docutils literal notranslate"><span class="pre">Lock</span></code>类密切相关。</p>
</section>
<section id="performance-goals">
<h3>2.2 Performance Goals 性能目标<a class="headerlink" href="#performance-goals" title="Link to this heading">#</a></h3>
<p>Java built-in locks (accessed using synchronized methods
and blocks) have long been a performance concern, and there is a
sizable literature on their construction (e.g., <a class="footnote-reference brackets" href="#id25" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#id26" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>). However,
the main focus of such work has been on minimizing space
overhead (because any Java object can serve as a lock) and on
minimizing time overhead when used in mostly-single-threaded
contexts on uniprocessors. Neither of these are especially
important concerns for synchronizers: Programmers construct
synchronizers only when needed, so there is no need to compact
space that would otherwise be wasted, and synchronizers are
used almost exclusively in multithreaded designs (increasingly
often on multiprocessors) under which at least occasional
contention is to be expected. So the usual JVM strategy of
optimizing locks primarily for the zero-contention case, leaving
other cases to less predictable “slow paths” <a class="footnote-reference brackets" href="#id27" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a> is not the right
tactic for typical multithreaded server applications that rely
heavily on java.util.concurrent.</p>
<p>Java 内置锁（使用<code class="docutils literal notranslate"><span class="pre">synchronized</span></code>方法和块）长期以来有性能问题，有大量关于它构造的
文献（例如 <a class="footnote-reference brackets" href="#id25" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#id26" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>）。然而，这类工作的主要焦点在于，在单核心、单线程的上下文种，
最小化空间开销（因为任何Java 对象都可以作为一个锁）以及时间开销。这两点对于同步器
来说都不是特别地重要：程序员只有在需要的时候才会构造同步器，因此没有必要紧凑的使用
空间来避免浪费，并且同步器几乎专门为多线程设计（多处理器越来越常见），在这种情况下
偶尔就会发生竞争。通常 JVM 的锁优化策略主要是为零竞争情况优化的，将其他情况留给不太可
预测的“慢路径” <a class="footnote-reference brackets" href="#id27" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a>，这对于依赖 java.util.concurrent 的典型的多线程服务器应用
来说并不是一个正确的策略。</p>
<p>Instead, the primary performance goal here is scalability: to
predictably maintain efficiency even, or especially, when
synchronizers are contended. Ideally, the overhead required to
pass a synchronization point should be constant no matter how
many threads are trying to do so. Among the main goals is to
minimize the total amount of time during which some thread is
permitted to pass a synchronization point but has not done so.
However, this must be balanced against resource considerations,
including total CPU time requirements, memory traffic, and
thread scheduling overhead. For example, spinlocks usually
provide shorter acquisition times than blocking locks, but usually
waste cycles and generate memory contention, so are not often
applicable.</p>
<p>相反，这里的主要性能目标是可伸缩性：即在同步器被争用时，能够可预测的保持效率。
理想情况下，无论多少线程正在尝试通过同步点，其所需要的开销应该是恒定的。主要目标之一
是尽量减少某个线程被允许通过同步点，但尚未这样做的总时间量（译注：竞态下获取资源的时间）。
然而，这些操作必须对资源利用均衡考量，包括需要 CPU 的总时间，内存流量和线程调度开销。
例如，自旋锁通常提高比阻塞锁更短的获取时间，但通常会浪费 CPU 周期和内存竞争，因此
并不普适。</p>
<p>These goals carry across two general styles of use. Most
applications should maximize aggregate throughput, tolerating, at
best, probabilistic guarantees about lack of starvation. However
in applications such as resource control, it is far more important
to maintain fairness of access across threads, tolerating poor
aggregate throughput. No framework can decide between these
conflicting goals on behalf of users; instead different fairness
policies must be accommodated.</p>
<p>这些目标贯穿两种基本的使用方式。大多数应用应该最大化总通吐量，最多只能容忍不发生饥饿
的概率上保证。然而，在资源控制等应用程序中，更重要的是在线程之间维持公平的资源访问，
可以容忍牺牲总通吐量。没有一个框架可以代表户在这些相互冲突的目标中作出决定；相反，
必须提供不同的公平策略来适应不同场景。</p>
<p>No matter how well-crafted they are internally, synchronizers
will create performance bottlenecks in some applications. Thus,
the framework must make it possible to monitor and inspect basic
operations to allow users to discover and alleviate bottlenecks.
This minimally (and most usefully) entails providing a way to
determine how many threads are blocked。</p>
<p>无论同步器内部设计的多么精良，他们都会成为某些应用的性能瓶颈。因此，框架必须提供监控和
检查内部操作的功能，以便用户能够发现和缓解瓶颈。至少应该（也是最有用的）包括提供一种
方法来确定有多少线程被阻塞。</p>
</section>
</section>
<section id="design-and-implementation">
<h2>3. DESIGN AND IMPLEMENTATION 设计和实现<a class="headerlink" href="#design-and-implementation" title="Link to this heading">#</a></h2>
<p>The basic ideas behind a synchronizer are quite straightforward.
An acquire operation proceeds as:</p>
<p>同步器背后的基本思路非常简单。获取操作的过程如下：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">synchronization</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">allow</span><span class="w"> </span><span class="n">acquire</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">enqueue</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">thread</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">already</span><span class="w"> </span><span class="n">queued</span><span class="p">;</span>
<span class="w">    </span><span class="n">possibly</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">thread</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">dequeue</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">thread</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">was</span><span class="w"> </span><span class="n">queued</span><span class="p">;</span>
</pre></div>
</div>
<p>And a release operation is:
释放操作如下：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">update</span><span class="w"> </span><span class="n">synchronization</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="n">may</span><span class="w"> </span><span class="n">permit</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">blocked</span><span class="w"> </span><span class="n">thread</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">acquire</span><span class="p">)</span>
<span class="w">    </span><span class="n">unblock</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">queued</span><span class="w"> </span><span class="n">threads</span><span class="p">;</span>
</pre></div>
</div>
<p>Support for these operations requires the coordination of three
basic components:
支持这些操作需要协调三个基本组件：</p>
<ul class="simple">
<li><p>Atomically managing synchronization state 原子的管理同步状态</p></li>
<li><p>Blocking and unblocking threads 对线程进行阻塞和解除阻塞</p></li>
<li><p>Maintaining queues 维护队列</p></li>
</ul>
<p>It might be possible to create a framework that allows each of
these three pieces to vary independently. However, this would
neither be very efficient nor usable. For example, the information
kept in queue nodes must mesh with that needed for unblocking,
and the signatures of exported methods depend on the nature of
synchronization state.</p>
<p>也许可以创建一个框架，允许这三者独立变化。但是，这样性能不高，也无法使用。
例如，队列节点中保留的信息必须和解除阻塞所需要的信息所匹配，并且导出方法的
签名，取决于同步状态的性质。</p>
<p>The central design decision in the synchronizer framework was
to choose a concrete implementation of each of these three
components, while still permitting a wide range of options in
how they are used. This intentionally limits the range of
applicability, but provides efficient enough support that there is
practically never a reason not to use the framework (and instead
build synchronizers from scratch) in those cases where it does
apply.</p>
<p>同步框架设计的核心是如何具体实现这三个组件，同时允许它们在使用方式上有很大的灵活性。
这个设计故意限制了适用范围，但是提高了足够高效的支持，因此，在适合的情况下就应该使用
这个框架（而不是从头开始构建同步器）。</p>
<section id="synchronization-state">
<h3>3.1 Synchronization State 同步状态<a class="headerlink" href="#synchronization-state" title="Link to this heading">#</a></h3>
<p>Class <code class="docutils literal notranslate"><span class="pre">AbstractQueuedSynchronizer</span></code> maintains synchro-
nization state using only a single (32bit) <code class="docutils literal notranslate"><span class="pre">int</span></code>, and exports
<code class="docutils literal notranslate"><span class="pre">getState</span></code>, <code class="docutils literal notranslate"><span class="pre">setState</span></code>, and <code class="docutils literal notranslate"><span class="pre">compareAndSetState</span></code>
operations to access and update this state. These methods in turn
rely on <code class="docutils literal notranslate"><span class="pre">java.util.concurrent.atomic</span></code> support providing JSR133
(Java Memory Model) compliant <code class="docutils literal notranslate"><span class="pre">volatile</span></code> semantics on reads
and writes, and access to native <code class="docutils literal notranslate"><span class="pre">compare-and-swap</span></code> or <code class="docutils literal notranslate"><span class="pre">load-</span> <span class="pre">linked/store-conditional</span></code> instructions to implement <code class="docutils literal notranslate"><span class="pre">compare-</span> <span class="pre">AndSetState</span></code>, that atomically sets state to a given new value
only if it holds a given expected value.</p>
<p><code class="docutils literal notranslate"><span class="pre">AbstractQueuedSynchronizer</span></code> 类仅使用一个（32 位）<code class="docutils literal notranslate"><span class="pre">int</span></code>来维护同步状态，
并且通过对外暴露<code class="docutils literal notranslate"><span class="pre">getState</span></code>, <code class="docutils literal notranslate"><span class="pre">setState</span></code>, and <code class="docutils literal notranslate"><span class="pre">compareAndSetState</span></code>方法来
访问和改变这个状态。这些方法依赖于<code class="docutils literal notranslate"><span class="pre">java.util.concurrent.atomic</span></code>包，这个包
提供了 JSR133（Java 内存模型）兼容的<code class="docutils literal notranslate"><span class="pre">volatile</span></code>读、写语义，并且通过访问
<code class="docutils literal notranslate"><span class="pre">compare-and-swap</span></code> 或 <code class="docutils literal notranslate"><span class="pre">load-linked/store-conditional</span></code> 原生指令，来实现
<code class="docutils literal notranslate"><span class="pre">compare-AndSetState</span></code>，这个指令只有在状态值持有预期值时，才将状态原子地设置为
给定的新值。</p>
<p>Restricting synchronization state to a 32bit <code class="docutils literal notranslate"><span class="pre">int</span></code> was a pragmatic
decision. While JSR166 also provides atomic operations on 64bit
<code class="docutils literal notranslate"><span class="pre">long</span></code> fields, these must still be emulated using internal locks on
enough platforms that the resulting synchronizers would not
perform well. In the future, it seems likely that a second base
class, specialized for use with 64bit state (i.e., with <code class="docutils literal notranslate"><span class="pre">long</span></code> control
arguments), will be added. However, there is not now a
compelling reason to include it in the package. Currently, 32 bits
suffice for most applications. Only one <code class="docutils literal notranslate"><span class="pre">java.util.concurrent</span></code>
synchronizer class, <code class="docutils literal notranslate"><span class="pre">CyclicBarrier</span></code>, would require more bits
to maintain state, so instead uses locks (as do most higher-level
utilities in the package).</p>
<p>将同步状态限制为 32位的<code class="docutils literal notranslate"><span class="pre">int</span></code>是一个务实的决定。虽然 JSR166 也提供了对 64位<code class="docutils literal notranslate"><span class="pre">long</span></code>
字段的原子操作，但是，在部分平台上，仍然需要内部锁来模拟这些操作，从而导致生成的同步器
性能不佳。将来，可能会再添加一个基类，专门用来处理 64位状态（即具有<code class="docutils literal notranslate"><span class="pre">long</span></code>的控制参数）。
然而，目前还没有充分的理由将其包含在该包中。目前，32 位对于大多数应用程序来说已经足够。
<code class="docutils literal notranslate"><span class="pre">java.util.concurrent</span></code> 中只有<code class="docutils literal notranslate"><span class="pre">CyclicBarrier</span></code>一个同步器类，需要更多的位来维护状态，
因此它使用了锁（就像这个包中的大多数高级工具一样）。</p>
<p>Concrete classes based on <code class="docutils literal notranslate"><span class="pre">AbstractQueuedSynchronizer</span></code>
must define methods <code class="docutils literal notranslate"><span class="pre">tryAcquire</span></code> and <code class="docutils literal notranslate"><span class="pre">tryRelease</span></code> in terms
of these exported state methods in order to control the acquire
and release operations. The <code class="docutils literal notranslate"><span class="pre">tryAcquire</span></code> method must return
<code class="docutils literal notranslate"><span class="pre">true</span></code> if synchronization was acquired, and the <code class="docutils literal notranslate"><span class="pre">tryRelease</span></code>
method must return <code class="docutils literal notranslate"><span class="pre">true</span></code> if the new synchronization state may
allow future acquires. These methods accept a single <code class="docutils literal notranslate"><span class="pre">int</span></code>
argument that can be used to communicate desired state; for
example in a reentrant lock, to re-establish the recursion count
when re-acquiring the lock after returning from a condition wait.
Many synchronizers do not need such an argument, and so just
ignore it.</p>
<p>基于<code class="docutils literal notranslate"><span class="pre">AbstractQueuedSynchronizer</span></code>的具体类必须根据这些暴露的状态方法，
来定义方法 <code class="docutils literal notranslate"><span class="pre">tryAcquire</span></code> 和 <code class="docutils literal notranslate"><span class="pre">tryRelease</span></code> ，从而控制获取和释放操作。
<code class="docutils literal notranslate"><span class="pre">tryAcquire</span></code>必须在获取同步状态成功后返回<code class="docutils literal notranslate"><span class="pre">true</span></code>，<code class="docutils literal notranslate"><span class="pre">tryRelease</span></code>必须在
在将来可能获取新的同步状态时返回<code class="docutils literal notranslate"><span class="pre">true</span></code>。这些方法接受一个单独的<code class="docutils literal notranslate"><span class="pre">int</span></code>参数，
这个参数可以和所需的状态进行通信。例如，在可重入锁中，可以在条件等待返回后，
重新获取锁时重新建立递归计数。许多同步器不需要同步这个参数，忽视它即可。</p>
</section>
<section id="blocking">
<h3>3.2 Blocking 阻塞<a class="headerlink" href="#blocking" title="Link to this heading">#</a></h3>
<p>Until JSR166, there was no Java API available to block and
unblock threads for purposes of creating synchronizers that are
not based on built-in monitors. The only candidates were
<code class="docutils literal notranslate"><span class="pre">Thread.suspend</span></code> and <code class="docutils literal notranslate"><span class="pre">Thread.resume</span></code>, which are
unusable because they encounter an unsolvable race problem: If
an unblocking thread invokes <code class="docutils literal notranslate"><span class="pre">resume</span></code> before the blocking
thread has executed <code class="docutils literal notranslate"><span class="pre">suspend</span></code>, the <code class="docutils literal notranslate"><span class="pre">resume</span></code> operation will have
no effect.</p>
<p>在 JSR166 以前，除了内置的监视器，没有可用的阻塞和解除阻塞线程的 Java API 来
创建同步器。唯一的选择是使用 <code class="docutils literal notranslate"><span class="pre">Thread.suspend</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Thread.resume</span></code>，但是也不能
使用它们，因为会遇到一个无法解决的竞争问题：如果一个解除阻塞的线程先调用了 <code class="docutils literal notranslate"><span class="pre">resume</span></code>，
阻塞线程后执行<code class="docutils literal notranslate"><span class="pre">suspend</span></code> ，那么<code class="docutils literal notranslate"><span class="pre">resume</span></code>操作将没有任何作用。</p>
<p>The <code class="docutils literal notranslate"><span class="pre">java.util.concurrent.locks</span></code> package includes a <code class="docutils literal notranslate"><span class="pre">LockSup-port</span></code>
class with methods that address this problem. Method
<code class="docutils literal notranslate"><span class="pre">LockSupport.park</span></code> blocks the current thread unless or until
a <code class="docutils literal notranslate"><span class="pre">LockSupport.unpark</span></code> has been issued. (Spurious wakeups
are also permitted.) Calls to <code class="docutils literal notranslate"><span class="pre">unpark</span></code> are not “counted”, so
multiple <code class="docutils literal notranslate"><span class="pre">unparks</span></code> before a <code class="docutils literal notranslate"><span class="pre">park</span></code> only unblock a single <code class="docutils literal notranslate"><span class="pre">park</span></code>.
Additionally, this applies per-thread, not per-synchronizer. A
thread invoking <code class="docutils literal notranslate"><span class="pre">park</span></code> on a new synchronizer might return
immediately because of a “leftover” <code class="docutils literal notranslate"><span class="pre">unpark</span></code> from a previous
usage. However, in the absence of an <code class="docutils literal notranslate"><span class="pre">unpark</span></code>, its next
invocation will block. While it would be possible to explicitly
clear this state, it is not worth doing so. It is more efficient to
invoke <code class="docutils literal notranslate"><span class="pre">park</span></code> multiple times when it happens to be necessary.</p>
<p><code class="docutils literal notranslate"><span class="pre">java.util.concurrent.locks</span></code> 包含一个名为 <code class="docutils literal notranslate"><span class="pre">LockSup-port</span></code> 的类，这个
类的方法解决了这个问题。<code class="docutils literal notranslate"><span class="pre">LockSupport.park</span></code> 方法会阻塞当前线程，直到发出
<code class="docutils literal notranslate"><span class="pre">LockSupport.unpark</span></code> 指令。（也允许虚假唤醒）对<code class="docutils literal notranslate"><span class="pre">unpark</span></code> 的调用不会“计数”，
因此在 <code class="docutils literal notranslate"><span class="pre">park</span></code> 之前多次调用<code class="docutils literal notranslate"><span class="pre">unparks</span></code>只会解除一个<code class="docutils literal notranslate"><span class="pre">park</span></code>。此外，这种情况是针对
每个线程，而不是每个同步器。一个线程在一个新的同步器上调用可能会立即返回，因为
之前使用的同步器上有一个“残留”的<code class="docutils literal notranslate"><span class="pre">unpark</span></code>。然而，如果没有调用<code class="docutils literal notranslate"><span class="pre">unpark</span></code>，下一次
调用就会阻塞。虽然可以显示的清除这个状态，但没有必要。必要时，多次调用<code class="docutils literal notranslate"><span class="pre">park</span></code>更高效。</p>
<p>This simple mechanism is similar to those used, at some level, in
the Solaris-9 thread library <a class="footnote-reference brackets" href="#id28" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a>, in WIN32 “consumable events”,
and in the Linux NPTL thread library, and so maps efficiently to
each of these on the most common platforms Java runs on.
(However, the current Sun Hotspot JVM reference
implementation on Solaris and Linux actually uses a pthread
condvar in order to fit into the existing runtime design.) The
<code class="docutils literal notranslate"><span class="pre">park</span></code> method also supports optional relative and absolute
timeouts, and is integrated with JVM <code class="docutils literal notranslate"><span class="pre">Thread.interrupt</span></code>
support — interrupting a thread unparks it.</p>
<p>这种简单的机制类似于 Solaris-9 线程库<a class="footnote-reference brackets" href="#id28" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a>、WIN32 的“可消耗事件”和 Linux 中的
NPTL 线程库，因此这在常见的 Java 运行平台上都可以高效运行。 （然而，当前的 Sun Hotspot JVM
实际上参考 Solaris 和 Linux 使用了一个 pthread condvar[^注1]，以适应当前的运行设计）
<code class="docutils literal notranslate"><span class="pre">park</span></code>操作还支持设置超时选项，可以是绝对时间和相对时间，并且于 JVM 的<code class="docutils literal notranslate"><span class="pre">Thread.interrupt</span></code>
集成——中断一个线程会解除其阻塞。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><strong>pthread condvar</strong>: POSIX 线程库（Pthreads）中的条件变量（condition variable）。</p>
<p>条件变量是用于线程间同步的一种机制，通常与互斥锁一起使用。它允许线程在等待某个条件成立时进入阻塞状态，并在条件满足时唤醒等待的线程。
pthread condvar 提供了以下几个主要操作：</p>
<ul class="simple">
<li><p>pthread_cond_init: 初始化条件变量。</p></li>
<li><p>pthread_cond_signal: 唤醒一个等待在条件变量上的线程。</p></li>
<li><p>pthread_cond_broadcast: 唤醒所有等待在条件变量上的线程。</p></li>
<li><p>pthread_cond_wait: 等待条件变量，同时释放相关的互斥锁，并在条件变量被信号唤醒时重新获取互斥锁。</p></li>
<li><p>pthread_cond_timedwait: 类似于 pthread_cond_wait，但是可以设置超时。</p></li>
</ul>
</div>
</section>
<section id="queues">
<h3>3.3 Queues 队列<a class="headerlink" href="#queues" title="Link to this heading">#</a></h3>
<p>The heart of the framework is maintenance of queues of blocked
threads, which are restricted here to FIFO queues. Thus, the
framework does not support priority-based synchronization.</p>
<p>这个框架的核心是维护阻塞线程队列，这些队列在这里被限制为 FIFO 队列。因此，这个框架
不支持基于优先级的同步。</p>
<p>These days, there is little controversy that the most appropriate
choices for synchronization queues are non-blocking data
structures that do not themselves need to be constructed using
lower-level locks. And of these, there are two main candidates:
variants of Mellor-Crummey and Scott (MCS) locks <a class="footnote-reference brackets" href="#id29" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>, and
variants of Craig, Landin, and Hagersten (CLH) locks <a class="footnote-reference brackets" href="#id30" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id31" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id32" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>.
Historically, CLH locks have been used only in spinlocks.
However, they appeared more amenable than MCS for use in the
synchronizer framework because they are more easily adapted to
handle cancellation and timeouts, so were chosen as a basis. The
resulting design is far enough removed from the original CLH
structure to require explanation.</p>
<p>如今，普遍认为最适合同步队列的选择是非阻塞数据结构，非阻塞数据结构不需要使用较低级别
的锁来构建。在这些选择中，有两个主要的候选者：Mellor-Crummey 和 Scott (MCS)
锁的变体<a class="footnote-reference brackets" href="#id29" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>，以及 Craig、Landin 和 Hagersten (CLH) 锁的变体<a class="footnote-reference brackets" href="#id30" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id31" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id32" id="id20" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>。
从历史上看，CLH 锁仅在自旋锁中被使用。然而，与 MCS 相比，CLH 似乎更适合用于同步器框架，
因为 CLH 更适合处理取消和超时操作，因此选择 CLH 作为同步框架实现的基础。这样得到的
设计与原始的 CLH 结构有很大的差异，因此需要额外解释说明。</p>
<p>A CLH queue is not very queue-like, because its enqueuing and
dequeuing operations are intimately tied to its uses as a lock. It is
a linked queue accessed via two atomically updatable fields,
<code class="docutils literal notranslate"><span class="pre">head</span></code> and <code class="docutils literal notranslate"><span class="pre">tail</span></code>, both initially pointing to a dummy node.</p>
<p>CLH 队列并不像传统的队列，因为它的入队和出队操作与它作为锁紧密相关。它是一个链式队列，
可以访问<code class="docutils literal notranslate"><span class="pre">head</span></code>和<code class="docutils literal notranslate"><span class="pre">tail</span></code>这两个字段，并且支持原子更新，这两个字段在初始化时指向一个虚拟节点。</p>
<p><img alt="queues" src="../_images/queues.png" /></p>
<p>A new node, <code class="docutils literal notranslate"><span class="pre">node</span></code>, is enqueued using an atomic operation:</p>
<p><code class="docutils literal notranslate"><span class="pre">node</span></code>是一个新节点，其原子化入队操作：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">pred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">tail</span><span class="p">.</span><span class="na">compareAndSet</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">));</span>
</pre></div>
</div>
<p>The release status for each node is kept in its predecessor node.
So, the “spin” of a spinlock looks like:</p>
<p>每个节点的释放状态都保存在前驱节点中。因此，自旋锁的“自旋”操作如下：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">pred</span><span class="p">.</span><span class="na">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">RELEASED</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="c1">// spin</span>
</pre></div>
</div>
<p>A dequeue operation after this spin simply entails setting the
<code class="docutils literal notranslate"><span class="pre">head</span></code> field to the node that just got the lock:</p>
<p>自旋之后的出队后，只需要将<code class="docutils literal notranslate"><span class="pre">head</span></code>字段设置为刚刚获得锁的节点即可。</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">;</span>
</pre></div>
</div>
<p>Among the advantages of CLH locks are that enqueuing and
dequeuing are fast, lock-free, and obstruction free (even under
contention, one thread will always win an insertion race so will
make progress); that detecting whether any threads are waiting is
also fast (just check if <code class="docutils literal notranslate"><span class="pre">head</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">tail</span></code>); and that
release status is decentralized, avoiding some memory
contention.</p>
<p>CLH 自旋锁的优点包括：入队和出队操作快、无锁且无阻塞（即使在竞争情况下，
总是会有一个线程会赢得插入的机会，因此整个任务一直可以取得进展）；检测是否有其他
线程正在等待也很快（只需要检查<code class="docutils literal notranslate"><span class="pre">head</span></code>与<code class="docutils literal notranslate"><span class="pre">tail</span></code>是否相同）；释放状态是分散的，
避免了一些内存竞争。</p>
<p>In the original versions of CLH locks, there were not even links
connecting nodes. In a spinlock, the <code class="docutils literal notranslate"><span class="pre">pred</span></code> variable can be held
as a local. However, Scott and Scherer<a class="footnote-reference brackets" href="#id32" id="id21" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a> showed that by
explicitly maintaining predecessor fields within nodes, CLH
locks can deal with timeouts and other forms of cancellation: If a
node’s predecessor cancels, the node can slide up to use the
previous node’s status field.</p>
<p>在最初的 CLH 锁中，节点之间甚至没有链接。在自旋锁中，<code class="docutils literal notranslate"><span class="pre">pred</span></code>变量可以作为局部变量存在。
然而， Scott 和 Scherer<a class="footnote-reference brackets" href="#id32" id="id22" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a> 表明，通过在节点之间明确维护前驱字段，CLH 锁可以处理
超时和其他形式的取消操作：如果一个节点的前驱节点取消了，这个节点就可以滑动上去使用前一个节点的状态字段。</p>
<p>The main additional modification needed to use CLH queues for
blocking synchronizers is to provide an efficient way for one
node to locate its successor. In spinlocks, a node need only
change its status, which will be noticed on next spin by its
successor, so links are unnecessary. But in a blocking
synchronizer, a node needs to explicitly wake up (<code class="docutils literal notranslate"><span class="pre">unpark</span></code>) its
successor.</p>
<p>将 CLH 队列</p>
</section>
<section id="condition-queues">
<h3>3.4 Condition Queues 条件队列<a class="headerlink" href="#condition-queues" title="Link to this heading">#</a></h3>
<ol class="arabic simple" start="2001">
<li></li>
</ol>
<ol class="arabic simple" start="2002">
<li></li>
</ol>
<hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id23" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id2">2</a>)</span>
<p>Andrews, G. Concurrent Programming. Wiley, 1991.</p>
</aside>
<aside class="footnote brackets" id="id24" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id3">1</a>,<a role="doc-backlink" href="#id4">2</a>)</span>
<p>Holmes, D. Synchronisation Rings, PhD Thesis, Macquarie
University, 1999.</p>
</aside>
<aside class="footnote brackets" id="id25" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id5">1</a>,<a role="doc-backlink" href="#id8">2</a>)</span>
<p>Agesen, O., D. Detlefs, A. Garthwaite, R. Knippel, Y. S.
Ramakrishna, and D. White. An Efficient Meta-lock for
Implementing Ubiquitous Synchronization. ACM OOPSLA
Proceedings, 1999.</p>
</aside>
<aside class="footnote brackets" id="id26" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id6">1</a>,<a role="doc-backlink" href="#id9">2</a>)</span>
<p>Bacon, D. Thin Locks: Featherweight Synchronization for
Java. ACM PLDI Proceedings, 1998.</p>
</aside>
<aside class="footnote brackets" id="id27" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id7">1</a>,<a role="doc-backlink" href="#id10">2</a>)</span>
<p>Zhang, H., S. Liang, and L. Bak. Monitor Conversion in a
Multithreaded Computer System. United States Patent
6,691,304. 2004.</p>
</aside>
<aside class="footnote brackets" id="id28" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id11">1</a>,<a role="doc-backlink" href="#id12">2</a>)</span>
<p>Sun Microsystems. Multithreading in the Solaris Operating
Environment . White paper available at
http://wwws.sun.com/software/solaris/whitepapers.html</p>
</aside>
<aside class="footnote brackets" id="id29" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id13">1</a>,<a role="doc-backlink" href="#id17">2</a>)</span>
<p>Mellor-Crummey, J.M., and M. L. Scott. Algorithms for
Scalable Synchronization on Shared-Memory
Multiprocessors. ACM Trans. on Computer Systems,
February 1991</p>
</aside>
<aside class="footnote brackets" id="id30" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id14">1</a>,<a role="doc-backlink" href="#id18">2</a>)</span>
<p>Craig, T. S. Building FIFO and priority-queueing spin locks
from atomic swap. Technical Report TR 93-02-02,
Department of Computer Science, University of
Washington, Feb. 1993.</p>
</aside>
<aside class="footnote brackets" id="id31" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id15">1</a>,<a role="doc-backlink" href="#id19">2</a>)</span>
<p>Magnussen, P., A. Landin, and E. Hagersten. Queue locks
on cache coherent multiprocessors. 8th Intl. Parallel
Processing Symposium, Cancun, Mexico, Apr. 1994.</p>
</aside>
<aside class="footnote brackets" id="id32" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id16">1</a>,<a role="doc-backlink" href="#id20">2</a>,<a role="doc-backlink" href="#id21">3</a>,<a role="doc-backlink" href="#id22">4</a>)</span>
<p>M. L. Scott and W N. Scherer III. Scalable Queue-Based
Spin Locks with Timeout. 8th ACM Symp. on Principles
and Practice of Parallel Programming, Snowbird, UT, June</p>
</aside>
</aside>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../2-Rust/index.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Rust 相关</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="05-HashMap%E5%AE%9E%E7%8E%B0.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">HashMap实现</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023, lighk
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link " href="https://github.com/lighkLife" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">论文翻译-AQS</a><ul>
<li><a class="reference internal" href="#abstract">ABSTRACT 摘要</a></li>
<li><a class="reference internal" href="#categories-and-subject-descriptors">Categories and Subject Descriptors</a></li>
<li><a class="reference internal" href="#general-terms">General Terms</a></li>
<li><a class="reference internal" href="#keywords">Keywords</a></li>
<li><a class="reference internal" href="#introduction">1. INTRODUCTION 介绍</a></li>
<li><a class="reference internal" href="#requirements">2.REQUIREMENTS 要求</a><ul>
<li><a class="reference internal" href="#functionality">2.1 Functionality 功能</a></li>
<li><a class="reference internal" href="#performance-goals">2.2 Performance Goals 性能目标</a></li>
</ul>
</li>
<li><a class="reference internal" href="#design-and-implementation">3. DESIGN AND IMPLEMENTATION 设计和实现</a><ul>
<li><a class="reference internal" href="#synchronization-state">3.1 Synchronization State 同步状态</a></li>
<li><a class="reference internal" href="#blocking">3.2 Blocking 阻塞</a></li>
<li><a class="reference internal" href="#queues">3.3 Queues 队列</a></li>
<li><a class="reference internal" href="#condition-queues">3.4 Condition Queues 条件队列</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=7d86a446"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=32e29ea5"></script>
    <script kind="utterances">

    var commentsRunWhenDOMLoaded = cb => {
    if (document.readyState != 'loading') {
        cb()
    } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', cb)
    } else {
        document.attachEvent('onreadystatechange', function() {
        if (document.readyState == 'complete') cb()
        })
    }
}

var addUtterances = () => {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = "https://utteranc.es/client.js";
    script.async = "async";

    script.setAttribute("repo", "lighkLife/wiki");
    script.setAttribute("issue-term", "pathname");
    script.setAttribute("theme", "github-light");
    script.setAttribute("label", "comments");
    script.setAttribute("crossorigin", "anonymous");

    sections = document.querySelectorAll("section");
    if (sections !== null) {
        section = sections[sections.length-1];
        section.appendChild(script);
    }
}
commentsRunWhenDOMLoaded(addUtterances);
</script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    <script src="../_static/sphinxcontrib-images/LightBox2/lightbox2/dist/js/lightbox-plus-jquery.min.js?v=ffc8af2d"></script>
    <script src="../_static/sphinxcontrib-images/LightBox2/lightbox2-customize/jquery-noconflict.js?v=12818e64"></script>
    </body>
</html>